--- table 类扩展
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 無心道(15388152619).
--- DateTime: 2024/11/13 19:43
---

function table.contains(t, value)
    return table.getKey(t, value) ~= nil
end

---统计table的长度
function table.count(t)
    if not t then
        return 0
    end

    local n = 0
    for _, _ in pairs(t) do
        n = n + 1
    end
    return n
end

function table.copy(t)
    ---@class nt
    local nt = {}
    for k, v in pairs(t) do
        nt[k] = v
    end
    return nt
end

function table.copyFrom(t, from)
    for k, v in pairs(from) do
        t[k] = v
    end
    return t
end

function table.getKey(t, value)
    for k, v in pairs(t) do
        if v == value then
            return k
        end
    end
    return nil
end

function table.getValue(t, key)
    for k, v in pairs(t) do
        if k == key then
            return v
        end
    end
    return nil
end

function table.isArray(t)
    for i = 1, table.count(t) do
        if not t[i] then
            return false
        end
    end
    return true
end

function table.isNullOrEmpty(t)
    return table.isEmpty(t)
end

function table.notNullOrEmpty(t)
    return not table.isEmpty(t)
end

function table.isEmpty(t)
    if type(t) ~= "table" then
        return true
    end
    return t == nil or next(t) == nil
end

function table.notEmpty(t)
    return not table.isEmpty(t)
end

-- 将table的所有值转换为string
-- 可用于将科学计数形式转换为字符串发送给客户端
function table.valueConvertToString(t)
    local newTable = {}
    for k, v in pairs(t) do
        if type(v) == "table" then
            newTable[tostring(k)] = table.valueConvertToString(v)
        else
            newTable[tostring(k)] = tostring(v)
        end
    end
    return newTable
end

function table.keys(t)
    ---@class keys
    local keys = {}
    for k, v in pairs(t) do
        table.insert(keys, k)
    end
    return keys
end

-- 将t2合并到t1
function table.merge(t1, t2)
    for k, v in pairs(t2) do
        t1[k] = v
    end
end

function table.concatTable(t, t2)
    for k, v in pairs(t2) do
        table.insert(t, v)
    end
    return t
end

local function tableToString(t, processed)
    if type(t) ~= "table" or processed and table.contains(processed, t) then
        return tostring(t)
    end

    if processed then
        table.insert(processed, t)
    end

    local str
    if table.isArray(t) then
        for _, v in ipairs(t) do
            local item = processed and table.toString(v, processed) or tostring(v)
            str = str and (str .. ", " .. item) or item
        end
    else
        for k, v in pairs(t) do
            local item = (processed and table.toString(k, processed) or tostring(k)) .. ":" ..
                    (processed and table.toString(v, processed) or tostring(v))
            str = str and (str .. ", " .. item) or item
        end
    end
    return str and "{" .. str .. "}" or "{}"
end

local function tableToStringJsonFormat(t, processed, indent)
    if indent == nil then
        indent = ''
    end
    if type(t) ~= "table" or processed and table.contains(processed, t) then
        return tostring(t)
    end

    if processed then
        table.insert(processed, t)
    end

    local space = '    '
    local str
    if table.isArray(t) then
        for i = 1, table.count(t) do
            local v = t[i]
            local item = processed and tableToStringJsonFormat(v, processed, indent .. space) or tostring(v)
            item = string.format('[%s]:%s', i, item)
            str = str and string.format("%s\n%s%s%s", str, indent, space, item) or
                    string.format("%s%s%s", indent, space, item)
            -- item = '['..tostring(i)..']:'..item
            -- str = str and (str .. "\n" ..indent.. space .. item) or (indent.. space ..item)
        end
    else
        for k, v in pairs(t) do
            local kName = tostring(k)
            if string.isNullOrEmpty(kName) then
                local item = (processed and tableToStringJsonFormat(v, processed, indent .. space) or tostring(v))
                -- str = str and (str .. "\n" ..indent.. space .. item) or (indent..space..item)
                str = str and string.format("%s\n%s%s%s", str, indent, space, item) or
                        string.format("%s%s%s", indent, space, item)
            else
                local item = (processed and tableToStringJsonFormat(k, processed, indent .. space) or tostring(k)) ..
                        ":" ..
                        (processed and tableToStringJsonFormat(v, processed, indent .. space) or tostring(v))
                -- str = str and (str .. "\n" ..indent.. space .. item) or (indent..space..item)
                str = str and string.format("%s\n%s%s%s", str, indent, space, item) or
                        string.format("%s%s%s", indent, space, item)
            end

        end
    end
    return str and string.format("\n%s{\n%s\n%s}", indent, str, indent) or string.format("{\n%s}", indent)
    -- return str and "\n"..indent.."{\n"..str .. "\n"..indent.."}" or "{\n"..indent.."}"
end

function table.toString(t, recursive)
    return tableToString(t, recursive and {})
end

function table.toStringJsonFormat(t, recursive, indent, tablename)
    if type(t) ~= 'table' then
        return tostring(t)
    end
    table.sort(t, function(a, b)
        return string.byte(tostring(a)) < string.byte(tostring(b))
    end)
    if tablename then
        return string.format(' %s %s:%s', t, tablename, tableToStringJsonFormat(t, recursive and {}, indent))
    else
        return string.format(' %s %s', t, tableToStringJsonFormat(t, recursive and {}, indent))
    end

end

function table.values(t)
    ---@class values
    local values = {}
    for k, v in pairs(t) do
        table.insert(values, v)
    end
    return values
end
---@return void @根据value值删除，只能是table(List)对象，会重排k值
function table.removeByValue(t, value)
    for i = #t, 1, -1 do
        if t[i] == value then
            table.remove(t, i)
            return true
        end
    end

    return false
end

---@return void @根据value值删除，如果是table(List)对象，不会重排k值
function table.removeByKeyValue(t, value)
    for k, v in pairs(t) do
        if v == value then
            t[k] = nil
        end
    end
end
---@generic K,V
---@param list table<K, V> | V[]
---@param comp fun(a:K, b:K):boolean
---@return number @使用 table里面不要有keys和count这样的字段，for i = 1, #t.keys do
--        t[t.keys[i]]
--    end
function table.sortByKeys(t, comp)
    if not t.keys then
        t.keys = {}
    end
    t.count = 0
    local count = table.count(t) - 2 -- 要减掉keys和count这两个变量
    t.count = count
    for i = 1, #t.keys do
        t.keys[i] = nil
    end
    local keyIndex = 1
    for k, v in pairs(t) do
        if k ~= 'keys' and k ~= 'count' then
            t.keys[keyIndex] = k
            keyIndex = keyIndex + 1
        end
    end

    return table.sort(t.keys, comp)
end

---@param func function(s:table,k:any,v:any)
function table.find(t, func, selfTable, compareData)
    for k, v in pairs(t) do
        if func(selfTable, compareData, k, v) then
            return k, v
        end
    end
    return nil
end

---@generic V
---@param list table<number, V> | V[]
---@param func fun(a:V):boolean
---@return number,V
function table.findByCondi(list, func)
    for k, v in pairs(list) do
        if func(v) then
            return k, v
        end
    end
    return nil
end

---@generic V
---@param list table<V, any>
---@param func fun(a:V):boolean
---@return V,any
function table.findByCondiKey(list, func)
    for k, v in pairs(list) do
        if func(k) then
            return k, v
        end
    end
    return nil
end

-- 返回不重复的value
function table.diffValue(t)
    local temp = {}
    local hashTable = {}
    for _, value in pairs(t) do
        if hashTable[value] == nil then
            hashTable[value] = true
            table.insert(temp, value)
        end
    end
    return temp
end

function table.clear(t)
    for k, v in pairs(t) do
        t[k] = nil
    end
end

function table.clearWithoutFunc(t)
    for k, v in pairs(t) do
        if t[k] and type(t[k]) ~= 'function' then
            t[k] = nil
        end
    end
end

---@return void @键值对顺序遍历table。调用前需要调用forOrderCollectKeys
---@param ascending boolean @keys值升序或者降序排序，默认升序
function table.forOrder(t, func, ascending)
    if t.keys then
        table.clear(t.keys)
    else
        t.keys = {}
        for k, v in pairs(t) do
            t[k] = nil
        end
    end
    for k, v in pairs(t) do
        if v ~= t.keys then
            table.insert(t.keys, k)
        end
    end
    if ascending == nil then
        ascending = true
    end
    table.sort(t.keys, function(a, b)
        if ascending then
            return a < b
        else
            return b < a
        end

    end)
    for k, v in pairs(t.keys) do
        if func then
            func(t[v])
        end
    end
end
-----@param recalculateKeys boolean @table发生变化，如果需要顺序遍历table,传入true
-- function table.forOrderCollectKeys(t,recalculateKeys)
--    if not t.keys or recalculateKeys then
--        t.keys = table.keys(t)
--    end
-- end

function table.insertArray(t, t2)
    for k, v in pairs(t2) do
        table.insert(t, v)
    end
end

function table.maxValue(t)
    local maxValue = math.mininteger
    local key
    for k, v in pairs(t) do
        if type(v) == "number" and v > maxValue then
            maxValue = v
            key = k
        end
    end
    return maxValue, key
end

-- 去重
function table.unique(t, bArray, mainKey)
    local check = {}
    local n = {}
    local idx = 1
    for k, v in pairs(t) do
        local judgeKey = v
        if mainKey then
            judgeKey = v[mainKey] or v
        end
        if not check[judgeKey] then
            if bArray then
                n[idx] = v
                idx = idx + 1
            else
                n[k] = v
            end
            check[judgeKey] = true
        end
    end
    return n
end

function table.insertOpti(t, t2)
    t[#t + 1] = v
end

function table.AddRanage(t, t2)
    for k, v in pairs(t2) do
        t[#t + 1] = v
    end
    return t
end

--- 获取前N个表中元素
---@param N number 前多少个
---@param t table
function table.getTopN(N, t)
    N = N or #t -- 如果没有指定N，则获取所有数据
    local topN = {}
    for i = 1, math.min(N, #t) do
        table.insert(topN, t[i])
    end
    return topN
end

--- 合并两个table
function table.mergeTable(table1, table2)
    for key, value in pairs(table2) do
        local itemId = tonumber(key)
        local itemNum = tonumber(value)
        local oldNum = table1[itemId] or 0
        table1[itemId] = oldNum + itemNum
    end
end